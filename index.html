<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AirParty</title>
  <style>
    :root{
      --panel:#0f0f10;
      --panel2:#141416;
      --red:#ff2b2b;
      --text:#f3f3f3;
      --muted:#b9b9b9;
      --stroke:#2a2a2e;
      --shadow: rgba(0,0,0,.65);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      background:
        radial-gradient(1200px 700px at 20% 20%, rgba(255,43,43,.10), transparent 55%),
        radial-gradient(900px 600px at 80% 40%, rgba(255,43,43,.08), transparent 55%),
        linear-gradient(180deg, #050505, #080808 55%, #050505);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body:before{
      content:"";
      position:fixed; inset:0;
      background:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode: overlay;
      opacity:.35;
      pointer-events:none;
    }
    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
    }
    @media (max-width:860px){ .wrap{grid-template-columns:1fr} }
    .card{
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(255,255,255,.05), transparent 55%),
        linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--stroke);
      border-radius:18px;
      box-shadow: 0 18px 60px var(--shadow), inset 0 1px 0 rgba(255,255,255,.06);
      overflow:hidden;
    }
    .head{
      padding:18px 18px 14px 18px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{ display:flex; flex-direction:column; gap:3px; }
    .brand h1{
      margin:0; font-size:18px; letter-spacing:.6px;
      display:flex; align-items:center; gap:10px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background:var(--red);
      box-shadow: 0 0 0 4px rgba(255,43,43,.10), 0 0 18px rgba(255,43,43,.55);
    }
    .brand .sub{ color:var(--muted); font-size:12px; line-height:1.2; }
    .badge{
      font-size:12px;
      color: #ffd7d7;
      background: rgba(255,43,43,.10);
      border:1px solid rgba(255,43,43,.25);
      padding:7px 10px;
      border-radius:999px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      white-space:nowrap;
    }
    .content{ padding:18px; display:flex; flex-direction:column; gap:14px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .field{
      flex:1 1 260px;
      display:flex; align-items:center; gap:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), inset 0 -10px 25px rgba(0,0,0,.35);
      min-height:48px;
    }
    .field label{ font-size:12px; color:var(--muted); min-width:86px; }
    .field input[type="text"], .field input[type="url"]{
      width:100%; background:transparent; border:0; outline:none;
      color:var(--text); font-size:14px;
    }
    input[type="file"]{ width:100%; color:var(--muted); }
    .btn{
      border:1px solid rgba(255,43,43,.30);
      background:
        radial-gradient(120% 140% at 30% 20%, rgba(255,255,255,.12), transparent 40%),
        linear-gradient(180deg, rgba(255,43,43,.95), rgba(177,15,15,.95));
      color:#fff;
      padding:12px 14px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      box-shadow:
        0 14px 30px rgba(255,43,43,.18),
        0 8px 18px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -10px 16px rgba(0,0,0,.25);
      transition: transform .08s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.secondary{
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(120% 140% at 30% 20%, rgba(255,255,255,.08), transparent 45%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      color:var(--text);
      box-shadow: 0 14px 30px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.08), inset 0 -10px 16px rgba(0,0,0,.30);
    }
    .btn:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
    .hint{ color: var(--muted); font-size:12px; line-height:1.35; }
    .hr{ height:1px; background: rgba(255,255,255,.06); margin:2px 0; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .log{
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      min-height:150px;
      max-height:280px;
      overflow:auto;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .log div{ color:#dcdcdc; font-size:12px; line-height:1.35; margin:0 0 6px 0; }
    .log .err{ color:#ffb0b0; }
    .log .ok{ color:#b9ffcd; }
    .log .warn{ color:#ffe3a7; }
    audio{ width:100%; }
    .small{ font-size:12px; color:var(--muted); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="head">
        <div class="brand">
          <h1><span class="dot"></span> AirParty</h1>
          <div class="sub">Host a room • Share a link • Everyone plays together</div>
        </div>
        <div class="badge" id="statusBadge">Disconnected</div>
      </div>

      <div class="content">
        <div class="row">
          <div class="field">
            <label>WS Server</label>
            <input id="wsUrl" type="url" value="wss://airparty-backend-9url.onrender.com/ws" />
          </div>
          <button class="btn secondary" id="btnConnect">Connect</button>
        </div>

        <div class="row">
          <button class="btn" id="btnCreateRoom" disabled>Create Room (Host)</button>
          <button class="btn secondary" id="btnJoinRoom" disabled>Join Room</button>
        </div>

        <div class="row">
          <div class="field">
            <label>Room</label>
            <input id="roomId" type="text" placeholder="Auto (host) or paste from link" />
          </div>
          <button class="btn secondary" id="btnCopyLink" disabled>Copy Link</button>
        </div>

        <div class="row">
          <button class="btn secondary" id="btnRequestConnect" disabled>Request Host Connect</button>
          <button class="btn secondary" id="btnReconnectNow" disabled>Reconnect Now</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="field" style="flex:1 1 100%">
            <label>MP3</label>
            <input id="mp3File" type="file" accept="audio/mpeg,audio/mp3" />
          </div>
        </div>

        <div class="hint">
          If sockets drop (Render restart/deploy), this page auto-reconnects and re-joins the room.
        </div>

        <div class="log mono" id="log"></div>
      </div>
    </div>

    <div class="card">
      <div class="head">
        <div class="brand">
          <h1>Player</h1>
          <div class="sub">Start/Stop sync (human-ear tight)</div>
        </div>
        <div class="badge" id="roleBadge">Role: —</div>
      </div>

      <div class="content">
        <audio id="audio" controls preload="auto"></audio>

        <div class="row">
          <button class="btn" id="btnPlay" disabled>Play</button>
          <button class="btn secondary" id="btnPause" disabled>Pause</button>
          <button class="btn secondary" id="btnSync" disabled>Resync</button>
        </div>

        <div class="small mono">
          Offset: <span id="offsetMs">—</span> ms • Peers: <span id="peerCount">0</span> • Host: <span id="hostIdText">—</span> • Mode: <span id="modeText">—</span>
        </div>

        <div class="hint">
          iPhone: if you see an audio play block, tap the player once.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const audio = $("audio");

  function log(msg, cls="") {
    const d = document.createElement("div");
    d.textContent = msg;
    if (cls) d.className = cls;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function randId(len=8){
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let s = "";
    for (let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
    return s;
  }
  const nowMs = () => Date.now();

  let ws = null;
  let myId = randId(10);

  let room = "";
  let mode = "none"; // "host" | "listener" | "none"
  let hostId = "";

  let serverOffsetMs = 0;
  let pingInterval = null;

  let reconnectTimer = null;
  let reconnectAttempt = 0;
  let wantConnected = false;

  const pcs = new Map();
  const dataCh = new Map();
  const fileRx = new Map();

  const iceServers = [
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" },
    { urls: "stun:stun2.l.google.com:19302" },
    { urls: "stun:stun3.l.google.com:19302" },
    { urls: "stun:stun4.l.google.com:19302" }
  ];

  let hostFileMeta = null;
  let hostFileArrayBuffer = null;

  const statusBadge = $("statusBadge");
  const roleBadge = $("roleBadge");
  const peerCountEl = $("peerCount");
  const offsetMsEl = $("offsetMs");
  const hostIdText = $("hostIdText");
  const modeText = $("modeText");

  const btnConnect = $("btnConnect");
  const btnCreateRoom = $("btnCreateRoom");
  const btnJoinRoom = $("btnJoinRoom");
  const btnCopyLink = $("btnCopyLink");
  const btnRequestConnect = $("btnRequestConnect");
  const btnReconnectNow = $("btnReconnectNow");

  const btnPlay = $("btnPlay");
  const btnPause = $("btnPause");
  const btnSync = $("btnSync");

  const wsUrlInput = $("wsUrl");
  const roomIdInput = $("roomId");
  const fileInput = $("mp3File");

  function setStatus(text, ok=false){
    statusBadge.textContent = text;
    statusBadge.style.background = ok ? "rgba(185,255,205,.10)" : "rgba(255,43,43,.10)";
    statusBadge.style.borderColor = ok ? "rgba(185,255,205,.25)" : "rgba(255,43,43,.25)";
    statusBadge.style.color = ok ? "#b9ffcd" : "#ffd7d7";
  }
  function setRole(text){ roleBadge.textContent = "Role: " + text; }
  function updatePeerCount(){ peerCountEl.textContent = String(pcs.size); }
  function updateOffsetLabel(){ offsetMsEl.textContent = String(Math.round(serverOffsetMs)); }
  function updateHostLabel(){ hostIdText.textContent = hostId || "—"; }
  function updateModeLabel(){ modeText.textContent = mode; }

  function enableAfterConnect(enabled){
    btnCreateRoom.disabled = !enabled;
    btnJoinRoom.disabled = !enabled;
    btnReconnectNow.disabled = !enabled;
  }
  function enablePlayerControls(){
    const ready = !!audio.src;
    btnPlay.disabled = !ready;
    btnPause.disabled = !ready;
    btnSync.disabled = !ready;
  }

  function setLinkInUrl(roomId){
    const u = new URL(window.location.href);
    u.searchParams.set("room", roomId);
    history.replaceState({}, "", u.toString());
  }
  function getRoomFromUrl(){
    const u = new URL(window.location.href);
    return u.searchParams.get("room") || "";
  }

  function wsSend(obj){
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  function startPinging(){
    stopPinging();
    pingInterval = setInterval(() => {
      wsSend({ type:"ping", t0: nowMs() });
    }, 2000);
  }
  function stopPinging(){
    if (pingInterval) clearInterval(pingInterval);
    pingInterval = null;
  }

  function hardCloseAllPeers(){
    for (const [pid, pc] of pcs.entries()) {
      try { pc.close(); } catch {}
    }
    pcs.clear();
    dataCh.clear();
    fileRx.clear();
    updatePeerCount();
  }

  function scheduleReconnect(){
    if (!wantConnected) return;
    if (reconnectTimer) return;

    reconnectAttempt += 1;
    const delay = Math.min(12000, 700 + reconnectAttempt * 900);

    log(`Reconnecting in ${delay}ms...`, "warn");
    setStatus("Reconnecting...", false);

    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectSocket(true);
    }, delay);
  }

  function connectSocket(isAuto=false){
    const url = wsUrlInput.value.trim();
    if (!url) { alert("WS URL missing"); return; }

    try {
      if (ws) { try { ws.close(); } catch {} }
      ws = new WebSocket(url);
    } catch {
      log("WebSocket creation failed", "err");
      scheduleReconnect();
      return;
    }

    setStatus(isAuto ? "Reconnecting..." : "Connecting...", false);
    btnConnect.disabled = true;

    ws.onopen = () => {
      reconnectAttempt = 0;
      setStatus("Connected", true);
      enableAfterConnect(true);
      startPinging();
      log("WebSocket connected.", "ok");

      wsSend({ type:"hello", id: myId });

      // Auto re-join / re-create after reconnect
      setTimeout(() => {
        if (!room) room = roomIdInput.value.trim() || getRoomFromUrl();
        if (!room) return;

        if (mode === "host") {
          wsSend({ type:"create_room", room, id: myId });
          log("Auto: re-create room as Host", "ok");
        } else if (mode === "listener") {
          wsSend({ type:"join_room", room, id: myId });
          log("Auto: re-join room as Listener", "ok");
        }
      }, 200);
    };

    ws.onerror = () => {
      log("WebSocket error.", "err");
    };

    ws.onclose = () => {
      setStatus("Disconnected", false);
      btnConnect.disabled = false;
      enableAfterConnect(false);
      btnCopyLink.disabled = true;
      btnRequestConnect.disabled = true;
      stopPinging();

      hardCloseAllPeers();

      log("WebSocket disconnected.", "warn");
      scheduleReconnect();
    };

    ws.onmessage = async (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "error") {
        log("SERVER ERROR: " + (msg.message || "unknown"), "err");
        return;
      }

      if (msg.type === "hello_ack") {
        serverOffsetMs = (msg.serverNow || 0) - nowMs();
        updateOffsetLabel();
        log("Handshake OK.", "ok");
        return;
      }

      if (msg.type === "pong") {
        const t0 = msg.t0;
        const t1 = nowMs();
        const rtt = (t1 - t0);
        const approxServerAtT1 = (msg.serverNow || 0) + (rtt/2);
        serverOffsetMs = approxServerAtT1 - t1;
        updateOffsetLabel();
        return;
      }

      if (msg.type === "host_update") {
        hostId = msg.hostId || "";
        updateHostLabel();
        return;
      }

      if (msg.type === "room_created") {
        room = msg.room;
        roomIdInput.value = room;
        setLinkInUrl(room);
        btnCopyLink.disabled = false;

        mode = "host";
        updateModeLabel();

        hostId = myId;
        updateHostLabel();

        setRole("Host");
        log(`Room created: ${room}`, "ok");
        return;
      }

      if (msg.type === "room_joined") {
        room = msg.room;
        roomIdInput.value = room;
        setLinkInUrl(room);
        btnCopyLink.disabled = false;

        hostId = msg.hostId || "";
        updateHostLabel();

        if (mode !== "host") mode = "listener";
        updateModeLabel();

        setRole(hostId === myId ? "Host" : "Listener");
        btnRequestConnect.disabled = (hostId === myId);

        log(`Joined room: ${room} (host=${hostId || "?"})`, "ok");

        if (hostId && hostId !== myId) {
          setTimeout(requestHostOffer, 300);
          setTimeout(requestHostOffer, 1500);
        }
        return;
      }

      if (msg.type === "peer_joined") {
        const peerId = msg.peerId;
        log(`Peer joined: ${peerId}`, "ok");
        if (mode === "host") await createOffer(peerId);
        return;
      }

      if (msg.type === "peer_left") {
        closePeer(msg.peerId);
        log(`Peer left: ${msg.peerId}`, "warn");
        return;
      }

      if (msg.type === "relay") {
        const from = msg.from;
        const payload = msg.payload || {};

        if (payload.kind === "please_offer") {
          if (mode === "host") {
            log(`Listener ${from} requested offer`, "ok");
            await createOffer(from);
          }
          return;
        }

        if (payload.kind === "offer") { await handleOffer(from, payload.sdp); return; }
        if (payload.kind === "answer") { await handleAnswer(from, payload.sdp); return; }
        if (payload.kind === "ice") { await handleIce(from, payload.candidate); return; }
        if (payload.kind === "sync") { if (mode !== "host") listenerApplySync(payload); return; }
      }
    };
  }

  function requestHostOffer(){
    if (!room) room = roomIdInput.value.trim() || getRoomFromUrl();
    if (!room || !hostId || hostId === myId) {
      log("No host known yet. Join room first.", "warn");
      return;
    }
    log("Requesting host to connect...", "ok");
    wsSend({ type:"relay", room, to: hostId, from: myId, payload: { kind:"please_offer" } });
  }

  function makePC(peerId){
    const pc = new RTCPeerConnection({ iceServers });

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"ice", candidate: e.candidate } });
      }
    };

    pc.onconnectionstatechange = () => {
      log(`RTC(${peerId}) state: ${pc.connectionState}`, pc.connectionState === "connected" ? "ok" : "warn");
    };

    pc.ondatachannel = (e) => bindDataChannel(peerId, e.channel);

    pcs.set(peerId, pc);
    updatePeerCount();
    return pc;
  }

  function bindDataChannel(peerId, ch){
    dataCh.set(peerId, ch);
    ch.binaryType = "arraybuffer";

    ch.onopen = async () => {
      log(`DataChannel open with ${peerId}`, "ok");
      if (mode === "host" && hostFileMeta) {
        sendFileMeta(peerId);
        await sendFileData(peerId);
      } else if (mode === "listener") {
        ch.send(JSON.stringify({ kind:"need_file" }));
      }
    };
    ch.onclose = () => log(`DataChannel closed with ${peerId}`, "warn");
    ch.onerror = () => log(`DataChannel error with ${peerId}`, "err");

    ch.onmessage = async (ev) => {
      if (typeof ev.data === "string") {
        const msg = JSON.parse(ev.data);
        if (msg.kind === "file_meta") {
          fileRx.set(peerId, { chunks: [], mime: msg.type, name: msg.name });
          log(`Receiving "${msg.name}"...`, "ok");
        } else if (msg.kind === "file_end") {
          const state = fileRx.get(peerId);
          if (!state) return;
          const blob = new Blob(state.chunks, { type: state.mime || "audio/mpeg" });
          const url = URL.createObjectURL(blob);
          audio.src = url;
          audio.load();
          enablePlayerControls();
          log(`MP3 ready: ${state.name}`, "ok");
          fileRx.delete(peerId);
        } else if (msg.kind === "need_file") {
          if (mode === "host" && hostFileMeta) {
            sendFileMeta(peerId);
            await sendFileData(peerId);
          }
        }
      } else {
        const state = fileRx.get(peerId);
        if (!state) return;
        state.chunks.push(ev.data);
      }
    };
  }

  function sendFileMeta(peerId){
    const ch = dataCh.get(peerId);
    if (!ch || ch.readyState !== "open") return;
    ch.send(JSON.stringify({ kind:"file_meta", ...hostFileMeta }));
  }

  async function sendFileData(peerId){
    const ch = dataCh.get(peerId);
    if (!ch || ch.readyState !== "open") return;
    if (!hostFileArrayBuffer) return;

    const chunkSize = 16 * 1024;
    const buf = hostFileArrayBuffer;
    let offset = 0;

    log(`Sending file to ${peerId}...`, "ok");

    while (offset < buf.byteLength) {
      const slice = buf.slice(offset, offset + chunkSize);
      ch.send(slice);
      offset += chunkSize;

      if (ch.bufferedAmount > 4 * 1024 * 1024) {
        await new Promise(r => setTimeout(r, 40));
      } else {
        await new Promise(r => setTimeout(r, 0));
      }
    }

    ch.send(JSON.stringify({ kind:"file_end" }));
    log(`File sent to ${peerId}`, "ok");
  }

  async function createOffer(peerId){
    const pc = pcs.get(peerId) || makePC(peerId);
    const ch = pc.createDataChannel("file");
    bindDataChannel(peerId, ch);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"offer", sdp: pc.localDescription } });
  }

  async function handleOffer(peerId, sdp){
    const pc = pcs.get(peerId) || makePC(peerId);
    await pc.setRemoteDescription(sdp);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"answer", sdp: pc.localDescription } });
  }

  async function handleAnswer(peerId, sdp){
    const pc = pcs.get(peerId);
    if (!pc) return;
    await pc.setRemoteDescription(sdp);
  }

  async function handleIce(peerId, candidate){
    const pc = pcs.get(peerId);
    if (!pc) return;
    try { await pc.addIceCandidate(candidate); } catch {}
  }

  function closePeer(peerId){
    const pc = pcs.get(peerId);
    if (pc) pc.close();
    pcs.delete(peerId);
    dataCh.delete(peerId);
    fileRx.delete(peerId);
    updatePeerCount();
  }

  function scheduleAtServerTime(serverTimeTarget, fn){
    const localTarget = serverTimeTarget - serverOffsetMs;
    const delay = Math.max(0, localTarget - nowMs());
    setTimeout(fn, delay);
  }

  function hostBroadcast(payload){
    wsSend({ type:"relay", room, to:"*", from: myId, payload });
  }

  function hostPlay(){
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 700;
    const t = audio.currentTime || 0;
    hostBroadcast({ kind:"sync", action:"play", serverTimeTarget, atTime: t });
    scheduleAtServerTime(serverTimeTarget, () => {
      audio.currentTime = t;
      audio.play().catch(()=>{});
    });
  }

  function hostPause(){
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 350;
    const t = audio.currentTime || 0;
    hostBroadcast({ kind:"sync", action:"pause", serverTimeTarget, atTime: t });
    scheduleAtServerTime(serverTimeTarget, () => {
      audio.pause();
      audio.currentTime = t;
    });
  }

  function hostResync(){
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 350;
    const t = audio.currentTime || 0;
    const playing = !audio.paused;
    hostBroadcast({ kind:"sync", action:"resync", serverTimeTarget, atTime: t, playing });
  }

  function listenerApplySync(msg){
    const { action, serverTimeTarget, atTime, playing } = msg;
    scheduleAtServerTime(serverTimeTarget, async () => {
      try {
        const drift = Math.abs((audio.currentTime || 0) - (atTime || 0));
        if (drift > 0.08) audio.currentTime = atTime || 0;

        if (action === "play") {
          audio.currentTime = atTime || 0;
          await audio.play();
        } else if (action === "pause") {
          audio.pause();
          audio.currentTime = atTime || 0;
        } else if (action === "resync") {
          audio.currentTime = atTime || 0;
          if (playing) await audio.play();
          else audio.pause();
        }
      } catch {}
    });
  }

  btnConnect.onclick = () => {
    wantConnected = true;
    connectSocket(false);
  };

  btnReconnectNow.onclick = () => {
    wantConnected = true;
    if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
    connectSocket(true);
  };

  btnCreateRoom.onclick = () => {
    if (!ws || ws.readyState !== 1) return;
    mode = "host"; updateModeLabel();
    setRole("Host");

    room = randId(6);
    roomIdInput.value = room;

    wsSend({ type:"create_room", room, id: myId });
  };

  btnJoinRoom.onclick = () => {
    if (!ws || ws.readyState !== 1) return;
    mode = "listener"; updateModeLabel();
    setRole("Listener");

    room = roomIdInput.value.trim() || getRoomFromUrl();
    if (!room) return;

    wsSend({ type:"join_room", room, id: myId });
  };

  btnCopyLink.onclick = async () => {
    if (!room) return;
    const u = new URL(window.location.href);
    u.searchParams.set("room", room);
    try { await navigator.clipboard.writeText(u.toString()); log("Link copied.", "ok"); }
    catch { alert(u.toString()); }
  };

  btnRequestConnect.onclick = () => requestHostOffer();

  fileInput.onchange = async () => {
    if (!fileInput.files || !fileInput.files[0]) return;
    const f = fileInput.files[0];
    if (!f.type.includes("audio")) return;

    hostFileMeta = { name: f.name, type: f.type || "audio/mpeg", size: f.size };
    hostFileArrayBuffer = await f.arrayBuffer();

    const url = URL.createObjectURL(new Blob([hostFileArrayBuffer], { type: hostFileMeta.type }));
    audio.src = url;
    audio.load();
    enablePlayerControls();
    log(`Loaded MP3 (host): ${f.name}`, "ok");

    if (mode !== "host") { log("Only Host should choose MP3.", "warn"); return; }

    for (const [peerId, ch] of dataCh.entries()) {
      if (ch.readyState === "open") {
        sendFileMeta(peerId);
        await sendFileData(peerId);
      }
    }
  };

  btnPlay.onclick = () => { if (mode === "host") hostPlay(); else log("Only Host controls Play/Pause.", "warn"); };
  btnPause.onclick = () => { if (mode === "host") hostPause(); else log("Only Host controls Play/Pause.", "warn"); };
  btnSync.onclick = () => { if (mode === "host") hostResync(); else log("Only Host can resync.", "warn"); };

  audio.addEventListener("seeked", () => { if (mode === "host") hostResync(); });

  // Initial UI
  const urlRoom = getRoomFromUrl();
  if (urlRoom) roomIdInput.value = urlRoom;

  setStatus("Disconnected", false);
  setRole("—");
  updatePeerCount();
  updateHostLabel();
  updateModeLabel();

  // Auto-connect if opened via shared link
  if (getRoomFromUrl()) {
    wantConnected = true;
    connectSocket(true);
  }

  // Enable request button only after join/host update
  const origSetRole = setRole;
  setRole = (...args) => origSetRole(...args);
})();
</script>
</body>
</html>
