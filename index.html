<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AirParty</title>
  <style>
    :root{
      --bg:#070707;
      --panel:#0f0f10;
      --panel2:#141416;
      --red:#ff2b2b;
      --red2:#b10f0f;
      --text:#f3f3f3;
      --muted:#b9b9b9;
      --stroke:#2a2a2e;
      --shadow: rgba(0,0,0,.65);
      --shine: rgba(255,255,255,.06);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 700px at 20% 20%, rgba(255,43,43,.10), transparent 55%),
        radial-gradient(900px 600px at 80% 40%, rgba(255,43,43,.08), transparent 55%),
        radial-gradient(1200px 900px at 50% 90%, rgba(255,43,43,.06), transparent 60%),
        linear-gradient(180deg, #050505, #080808 55%, #050505);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding:18px;
    }

    /* rubber-ish texture */
    body:before{
      content:"";
      position:fixed; inset:0;
      background:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      mix-blend-mode: overlay;
      opacity:.35;
      pointer-events:none;
    }

    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
    }
    @media (max-width:860px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(255,255,255,.05), transparent 55%),
        linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--stroke);
      border-radius:18px;
      box-shadow:
        0 18px 60px var(--shadow),
        inset 0 1px 0 rgba(255,255,255,.06);
      overflow:hidden;
    }

    .card .head{
      padding:18px 18px 14px 18px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex; flex-direction:column; gap:3px;
    }
    .brand h1{
      margin:0;
      font-size:18px;
      letter-spacing:.6px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background:var(--red);
      box-shadow: 0 0 0 4px rgba(255,43,43,.10), 0 0 18px rgba(255,43,43,.55);
    }
    .brand .sub{
      color:var(--muted);
      font-size:12px;
      line-height:1.2;
    }

    .badge{
      font-size:12px;
      color: #ffd7d7;
      background: rgba(255,43,43,.10);
      border:1px solid rgba(255,43,43,.25);
      padding:7px 10px;
      border-radius:999px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      white-space:nowrap;
    }

    .content{ padding:18px; display:flex; flex-direction:column; gap:14px; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .field{
      flex:1 1 260px;
      display:flex;
      align-items:center;
      gap:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.05),
        inset 0 -10px 25px rgba(0,0,0,.35);
      min-height:48px;
    }
    .field label{ font-size:12px; color:var(--muted); min-width:86px; }
    .field input[type="text"], .field input[type="url"]{
      width:100%;
      background:transparent;
      border:0;
      outline:none;
      color:var(--text);
      font-size:14px;
    }
    .field input::placeholder{ color: rgba(243,243,243,.35); }

    input[type="file"]{
      width:100%;
      color:var(--muted);
    }

    .btn{
      border:1px solid rgba(255,43,43,.30);
      background:
        radial-gradient(120% 140% at 30% 20%, rgba(255,255,255,.12), transparent 40%),
        linear-gradient(180deg, rgba(255,43,43,.95), rgba(177,15,15,.95));
      color:#fff;
      padding:12px 14px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.2px;
      box-shadow:
        0 14px 30px rgba(255,43,43,.18),
        0 8px 18px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -10px 16px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .08s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px) scale(.99); filter:saturate(1.05); }
    .btn.secondary{
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(120% 140% at 30% 20%, rgba(255,255,255,.08), transparent 45%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      color:var(--text);
      box-shadow:
        0 14px 30px rgba(0,0,0,.45),
        inset 0 1px 0 rgba(255,255,255,.08),
        inset 0 -10px 16px rgba(0,0,0,.30);
    }
    .btn:disabled{
      opacity:.45; cursor:not-allowed; transform:none;
    }

    .hint{
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
    }

    .hr{ height:1px; background: rgba(255,255,255,.06); margin:2px 0; }

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
    }

    .log{
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
      min-height:120px;
      max-height:220px;
      overflow:auto;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .log div{ color:#dcdcdc; font-size:12px; line-height:1.35; margin:0 0 6px 0; }
    .log .err{ color:#ffb0b0; }
    .log .ok{ color:#b9ffcd; }
    .log .warn{ color:#ffe3a7; }

    .player{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    audio{ width:100%; }
    .small{
      font-size:12px; color:var(--muted);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- LEFT: Room + Upload -->
    <div class="card">
      <div class="head">
        <div class="brand">
          <h1><span class="dot"></span> AirParty</h1>
          <div class="sub">Host a room • Share a link • Everyone plays together</div>
        </div>
        <div class="badge" id="statusBadge">Disconnected</div>
      </div>

      <div class="content">
        <div class="row">
          <div class="field">
            <label>WS Server</label>
            <input id="wsUrl" type="url" placeholder="Paste your backend wss://.../ws" />
          </div>
          <button class="btn secondary" id="btnConnect">Connect</button>
        </div>

        <div class="row">
          <button class="btn" id="btnCreateRoom" disabled>Create Room (Host)</button>
          <button class="btn secondary" id="btnJoinRoom" disabled>Join Room</button>
        </div>

        <div class="row">
          <div class="field">
            <label>Room</label>
            <input id="roomId" type="text" placeholder="Auto (host) or paste from link" />
          </div>
          <button class="btn secondary" id="btnCopyLink" disabled>Copy Link</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="field" style="flex:1 1 100%">
            <label>MP3</label>
            <input id="mp3File" type="file" accept="audio/mpeg,audio/mp3" />
          </div>
        </div>

        <div class="hint">
          Host selects an MP3 → joins generate the same link → host sends the MP3 directly to listeners (no storage, no billing).
        </div>

        <div class="log mono" id="log"></div>
      </div>
    </div>

    <!-- RIGHT: Player + Controls -->
    <div class="card">
      <div class="head">
        <div class="brand">
          <h1>Player</h1>
          <div class="sub">Start/Stop/Seek sync (human-ear tight)</div>
        </div>
        <div class="badge" id="roleBadge">Role: —</div>
      </div>

      <div class="content player">
        <audio id="audio" controls preload="auto"></audio>

        <div class="row">
          <button class="btn" id="btnPlay" disabled>Play</button>
          <button class="btn secondary" id="btnPause" disabled>Pause</button>
          <button class="btn secondary" id="btnSync" disabled>Resync</button>
        </div>

        <div class="small mono">
          Time offset (server): <span id="offsetMs">—</span> ms • Peers: <span id="peerCount">0</span>
        </div>

        <div class="hint">
          Notes: For “sounds together” sync, we schedule Play/Pause at a shared server-time target and correct drift with small seeks.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= Utilities =========
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const audio = $("audio");

  function log(msg, cls="") {
    const d = document.createElement("div");
    d.textContent = msg;
    if (cls) d.className = cls;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function randId(len=8){
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let s = "";
    for (let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  function nowMs(){ return Date.now(); }

  // ========= State =========
  let ws = null;
  let myId = randId(10);
  let room = "";
  let isHost = false;

  // time sync
  let serverOffsetMs = 0; // serverNow - localNow
  let lastPingSentAt = 0;
  let pingInterval = null;

  // WebRTC
  const pcs = new Map();              // peerId -> RTCPeerConnection
  const dataCh = new Map();           // peerId -> RTCDataChannel
  const fileRx = new Map();           // peerId -> {chunks:[], totalBytes, receivedBytes, mime, name}
  const iceServers = [{ urls: "stun:stun.l.google.com:19302" }];

  // Host file
  let hostFile = null;
  let hostFileMeta = null; // {name, type, size}
  let hostFileArrayBuffer = null;

  // ========= UI =========
  const statusBadge = $("statusBadge");
  const roleBadge = $("roleBadge");
  const peerCountEl = $("peerCount");
  const offsetMsEl = $("offsetMs");

  const btnConnect = $("btnConnect");
  const btnCreateRoom = $("btnCreateRoom");
  const btnJoinRoom = $("btnJoinRoom");
  const btnCopyLink = $("btnCopyLink");

  const btnPlay = $("btnPlay");
  const btnPause = $("btnPause");
  const btnSync = $("btnSync");

  const wsUrlInput = $("wsUrl");
  const roomIdInput = $("roomId");
  const fileInput = $("mp3File");

  function setStatus(text, ok=false){
    statusBadge.textContent = text;
    statusBadge.style.background = ok ? "rgba(185,255,205,.10)" : "rgba(255,43,43,.10)";
    statusBadge.style.borderColor = ok ? "rgba(185,255,205,.25)" : "rgba(255,43,43,.25)";
    statusBadge.style.color = ok ? "#b9ffcd" : "#ffd7d7";
  }

  function setRole(text){
    roleBadge.textContent = "Role: " + text;
  }

  function updatePeerCount(){
    peerCountEl.textContent = String(pcs.size);
  }

  function enableAfterConnect(enabled){
    btnCreateRoom.disabled = !enabled;
    btnJoinRoom.disabled = !enabled;
  }

  function enablePlayerControls(){
    const ready = (!!audio.src || audio.srcObject) && (isHost || !isHost);
    btnPlay.disabled = !ready;
    btnPause.disabled = !ready;
    btnSync.disabled = !ready;
  }

  function setLinkInUrl(roomId){
    const u = new URL(window.location.href);
    u.searchParams.set("room", roomId);
    history.replaceState({}, "", u.toString());
  }

  function getRoomFromUrl(){
    const u = new URL(window.location.href);
    return u.searchParams.get("room") || "";
  }

  // ========= WebSocket Protocol =========
  // Client -> Server:
  // { type:"hello", id }
  // { type:"create_room", room, id }
  // { type:"join_room", room, id }
  // { type:"relay", room, to, from, payload:{...} }   // signaling + sync
  // { type:"ping", t0 }  // for time offset
  //
  // Server -> Client:
  // { type:"hello_ack", serverNow, id }
  // { type:"room_created", room }
  // { type:"room_joined", room, hostId, peers:[...] }
  // { type:"peer_joined", peerId }
  // { type:"peer_left", peerId }
  // { type:"relay", from, payload:{...}, serverNow }
  // { type:"pong", t0, serverNow }

  function wsSend(obj){
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  function startPinging(){
    stopPinging();
    pingInterval = setInterval(() => {
      lastPingSentAt = nowMs();
      wsSend({ type:"ping", t0: lastPingSentAt });
    }, 2000);
  }
  function stopPinging(){
    if (pingInterval) clearInterval(pingInterval);
    pingInterval = null;
  }

  function updateOffsetLabel(){
    offsetMsEl.textContent = String(Math.round(serverOffsetMs));
  }

  // ========= WebRTC Helpers =========
  function makePC(peerId){
    const pc = new RTCPeerConnection({ iceServers });
    pc.onicecandidate = (e) => {
      if (e.candidate) {
        wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"ice", candidate: e.candidate } });
      }
    };

    pc.onconnectionstatechange = () => {
      log(`RTC(${peerId}) state: ${pc.connectionState}`, pc.connectionState === "connected" ? "ok" : "warn");
    };

    pc.ondatachannel = (e) => {
      const ch = e.channel;
      bindDataChannel(peerId, ch);
    };

    pcs.set(peerId, pc);
    updatePeerCount();
    return pc;
  }

  function bindDataChannel(peerId, ch){
    dataCh.set(peerId, ch);
    ch.binaryType = "arraybuffer";

    ch.onopen = () => {
      log(`DataChannel open with ${peerId}`, "ok");
      // If host already has a file, push metadata prompt
      if (isHost && hostFileMeta) {
        sendFileMeta(peerId);
      }
    };

    ch.onclose = () => log(`DataChannel closed with ${peerId}`, "warn");
    ch.onerror = () => log(`DataChannel error with ${peerId}`, "err");

    ch.onmessage = async (ev) => {
      if (typeof ev.data === "string") {
        const msg = JSON.parse(ev.data);
        if (msg.kind === "file_meta") {
          // listener received metadata
          fileRx.set(peerId, { chunks: [], receivedBytes: 0, totalBytes: msg.size, mime: msg.type, name: msg.name });
          log(`Receiving "${msg.name}" (${msg.size} bytes) ...`, "ok");
        } else if (msg.kind === "file_end") {
          const state = fileRx.get(peerId);
          if (!state) return;
          const blob = new Blob(state.chunks, { type: state.mime || "audio/mpeg" });
          const url = URL.createObjectURL(blob);
          audio.src = url;
          audio.load();
          enablePlayerControls();
          log(`MP3 ready: ${state.name}`, "ok");
          fileRx.delete(peerId);
        } else if (msg.kind === "need_file") {
          // listener asks host for file
          if (isHost && hostFileMeta) {
            sendFileMeta(peerId);
            await sendFileData(peerId);
          }
        }
      } else {
        // binary chunk
        const state = fileRx.get(peerId);
        if (!state) return;
        state.chunks.push(ev.data);
        state.receivedBytes += ev.data.byteLength;
      }
    };
  }

  function sendFileMeta(peerId){
    const ch = dataCh.get(peerId);
    if (!ch || ch.readyState !== "open") return;
    ch.send(JSON.stringify({ kind:"file_meta", ...hostFileMeta }));
  }

  async function sendFileData(peerId){
    const ch = dataCh.get(peerId);
    if (!ch || ch.readyState !== "open") return;
    if (!hostFileArrayBuffer) return;

    const chunkSize = 16 * 1024;
    const buf = hostFileArrayBuffer;
    let offset = 0;

    log(`Sending file to ${peerId}...`, "ok");

    while (offset < buf.byteLength) {
      const slice = buf.slice(offset, offset + chunkSize);
      ch.send(slice);
      offset += chunkSize;
      // flow control
      if (ch.bufferedAmount > 4 * 1024 * 1024) {
        await new Promise(r => setTimeout(r, 40));
      } else {
        await new Promise(r => setTimeout(r, 0));
      }
    }

    ch.send(JSON.stringify({ kind:"file_end" }));
    log(`File sent to ${peerId}`, "ok");
  }

  async function createOffer(peerId){
    const pc = pcs.get(peerId) || makePC(peerId);
    const ch = pc.createDataChannel("file");
    bindDataChannel(peerId, ch);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"offer", sdp: pc.localDescription } });
  }

  async function handleOffer(peerId, sdp){
    const pc = pcs.get(peerId) || makePC(peerId);
    await pc.setRemoteDescription(sdp);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    wsSend({ type:"relay", room, to: peerId, from: myId, payload: { kind:"answer", sdp: pc.localDescription } });
  }

  async function handleAnswer(peerId, sdp){
    const pc = pcs.get(peerId);
    if (!pc) return;
    await pc.setRemoteDescription(sdp);
  }

  async function handleIce(peerId, candidate){
    const pc = pcs.get(peerId);
    if (!pc) return;
    try { await pc.addIceCandidate(candidate); } catch {}
  }

  function closePeer(peerId){
    const pc = pcs.get(peerId);
    if (pc) pc.close();
    pcs.delete(peerId);
    dataCh.delete(peerId);
    fileRx.delete(peerId);
    updatePeerCount();
  }

  // ========= Sync Controls =========
  // We schedule actions at serverTimeTarget, clients convert to local time:
  // localTarget = serverTimeTarget - serverOffsetMs
  function scheduleAtServerTime(serverTimeTarget, fn){
    const localTarget = serverTimeTarget - serverOffsetMs;
    const delay = Math.max(0, localTarget - nowMs());
    setTimeout(fn, delay);
  }

  function hostBroadcast(payload){
    // relay to everyone in room (server will fan out)
    wsSend({ type:"relay", room, to:"*", from: myId, payload });
  }

  function hostPlay(){
    // schedule ~700ms ahead
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 700;
    const t = audio.currentTime || 0;

    hostBroadcast({ kind:"sync", action:"play", serverTimeTarget, atTime: t });
    scheduleAtServerTime(serverTimeTarget, () => {
      audio.currentTime = t;
      audio.play().catch(()=>{});
    });
  }

  function hostPause(){
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 350;
    const t = audio.currentTime || 0;

    hostBroadcast({ kind:"sync", action:"pause", serverTimeTarget, atTime: t });
    scheduleAtServerTime(serverTimeTarget, () => {
      audio.pause();
      audio.currentTime = t;
    });
  }

  function hostResync(){
    const serverTimeTarget = (nowMs() + serverOffsetMs) + 350;
    const t = audio.currentTime || 0;
    const playing = !audio.paused;

    hostBroadcast({ kind:"sync", action:"resync", serverTimeTarget, atTime: t, playing });
  }

  function listenerApplySync(msg){
    const { action, serverTimeTarget, atTime, playing } = msg;

    scheduleAtServerTime(serverTimeTarget, async () => {
      try {
        // tiny correction first (human-ear tight)
        const drift = Math.abs((audio.currentTime || 0) - (atTime || 0));
        if (drift > 0.08) audio.currentTime = atTime || 0;

        if (action === "play") {
          audio.currentTime = atTime || 0;
          await audio.play();
        } else if (action === "pause") {
          audio.pause();
          audio.currentTime = atTime || 0;
        } else if (action === "resync") {
          audio.currentTime = atTime || 0;
          if (playing) await audio.play();
          else audio.pause();
        }
      } catch (e) {}
    });
  }

  // ========= Actions =========
  btnConnect.onclick = () => {
    const url = wsUrlInput.value.trim();
    if (!url) { alert("Paste WS Server URL first (wss://.../ws)"); return; }

    try {
      ws = new WebSocket(url);
    } catch {
      alert("Invalid WS URL");
      return;
    }

    setStatus("Connecting...", false);
    btnConnect.disabled = true;

    ws.onopen = () => {
      setStatus("Connected", true);
      enableAfterConnect(true);
      wsSend({ type:"hello", id: myId });
      startPinging();
      log("WebSocket connected.", "ok");
    };

    ws.onclose = () => {
      setStatus("Disconnected", false);
      btnConnect.disabled = false;
      enableAfterConnect(false);
      stopPinging();
      log("WebSocket disconnected.", "warn");
    };

    ws.onerror = () => {
      log("WebSocket error.", "err");
    };

    ws.onmessage = async (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "hello_ack") {
        // initialize offset from serverNow
        serverOffsetMs = (msg.serverNow || 0) - nowMs();
        updateOffsetLabel();

        // auto room from URL if present
        const urlRoom = getRoomFromUrl();
        if (urlRoom) {
          roomIdInput.value = urlRoom;
          room = urlRoom;
        }
      }

      if (msg.type === "pong") {
        const t0 = msg.t0;
        const t1 = nowMs();
        const rtt = (t1 - t0);
        const approxServerAtT1 = (msg.serverNow || 0) + (rtt/2);
        serverOffsetMs = approxServerAtT1 - t1;
        updateOffsetLabel();
        return;
      }

      if (msg.type === "room_created") {
        room = msg.room;
        roomIdInput.value = room;
        setLinkInUrl(room);
        btnCopyLink.disabled = false;

        isHost = true;
        setRole("Host");
        log(`Room created: ${room}`, "ok");
        return;
      }

      if (msg.type === "room_joined") {
        room = msg.room;
        roomIdInput.value = room;
        setLinkInUrl(room);
        btnCopyLink.disabled = false;

        isHost = (msg.hostId === myId);
        setRole(isHost ? "Host" : "Listener");
        log(`Joined room: ${room}`, "ok");

        // If listener, request file from host after peer connect
        return;
      }

      if (msg.type === "peer_joined") {
        const peerId = msg.peerId;
        log(`Peer joined: ${peerId}`, "ok");

        // Host initiates offer
        if (isHost) {
          await createOffer(peerId);
        }
        return;
      }

      if (msg.type === "peer_left") {
        closePeer(msg.peerId);
        log(`Peer left: ${msg.peerId}`, "warn");
        return;
      }

      if (msg.type === "relay") {
        const from = msg.from;
        const payload = msg.payload || {};

        if (payload.kind === "offer") {
          await handleOffer(from, payload.sdp);
          return;
        }
        if (payload.kind === "answer") {
          await handleAnswer(from, payload.sdp);
          return;
        }
        if (payload.kind === "ice") {
          await handleIce(from, payload.candidate);
          return;
        }
        if (payload.kind === "sync") {
          if (!isHost) listenerApplySync(payload);
          return;
        }

        return;
      }
    };
  };

  btnCreateRoom.onclick = () => {
    isHost = true;
    setRole("Host");
    room = randId(6);
    roomIdInput.value = room;
    wsSend({ type:"create_room", room, id: myId });
  };

  btnJoinRoom.onclick = () => {
    const r = roomIdInput.value.trim() || getRoomFromUrl();
    if (!r) { alert("Paste Room ID (or open a link with ?room=xxxxxx)"); return; }
    room = r;
    wsSend({ type:"join_room", room, id: myId });
    setRole("Listener");
  };

  btnCopyLink.onclick = async () => {
    if (!room) return;
    const u = new URL(window.location.href);
    u.searchParams.set("room", room);
    try {
      await navigator.clipboard.writeText(u.toString());
      log("Link copied to clipboard.", "ok");
    } catch {
      alert(u.toString());
    }
  };

  fileInput.onchange = async () => {
    if (!fileInput.files || !fileInput.files[0]) return;
    const f = fileInput.files[0];
    if (!f.type.includes("audio")) {
      alert("Please choose an MP3/audio file.");
      return;
    }

    hostFile = f;
    hostFileMeta = { name: f.name, type: f.type || "audio/mpeg", size: f.size };

    hostFileArrayBuffer = await f.arrayBuffer();
    const url = URL.createObjectURL(new Blob([hostFileArrayBuffer], { type: hostFileMeta.type }));
    audio.src = url;
    audio.load();

    enablePlayerControls();
    log(`Loaded MP3 locally: ${f.name}`, "ok");

    // If host, push file to any already-connected peers
    if (isHost) {
      for (const [peerId, ch] of dataCh.entries()) {
        if (ch.readyState === "open") {
          sendFileMeta(peerId);
          await sendFileData(peerId);
        }
      }
    } else {
      // listener asks host for file (once any data channel exists)
      for (const [peerId, ch] of dataCh.entries()) {
        if (ch.readyState === "open") {
          ch.send(JSON.stringify({ kind:"need_file" }));
        }
      }
    }
  };

  btnPlay.onclick = () => {
    if (isHost) hostPlay();
    else log("Only Host controls Play/Pause. (Host: press Play)", "warn");
  };

  btnPause.onclick = () => {
    if (isHost) hostPause();
    else log("Only Host controls Play/Pause. (Host: press Pause)", "warn");
  };

  btnSync.onclick = () => {
    if (isHost) hostResync();
    else log("Host can resync everyone.", "warn");
  };

  // When user scrubs locally, host can resync everyone automatically (optional)
  audio.addEventListener("seeked", () => {
    if (isHost && !audio.paused) hostResync();
    if (isHost && audio.paused) hostResync();
  });

  // Prepare for URL room auto-fill
  const r = getRoomFromUrl();
  if (r) roomIdInput.value = r;

  setStatus("Disconnected", false);
  setRole("—");
  updatePeerCount();
})();
</script>
</body>
</html>
